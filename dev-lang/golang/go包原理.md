### 1、包的引入原理

- 程序的初始化和执行都起始于main包。
- 如果main包还导入了其它的包，那么就会在编译时将它们依次导入。
- 有时一个包会被多个包同时导入，那么它只会被导入一次（例如很多包可能都会用到fmt包，但它只会被导入一次，因为没有必要导入多次）。
- 当一个包被导入时，如果该包还导入了其它的包，那么会先将其它包导入进来，然后再对这些包中的包级常量和变量进行初始化，接着执行init函数（如果有的话），依次类推。-
- 等所有被导入的包都加载完毕了，就会开始对main包中的包级常量和变量进行初始化，然后执行main包中的init函数（如果存在的话），最后执行main函数。

![包导入](https://github.com/lizj3624/mynote/blob/master/dev-lang/golang/pictures/go-import-package.jpeg)

### 2、包一些原则

- 多个源文件可同属于一个包，只要声明时package指定的包名一样；
- 一个包对应生成一个*.a文件，生成的文件名并不是包名+.a组成，应该是目录名+.a组成
- go install ××× 这里对应的并不是包名，而是路径名！！
- import ××× 这里使用的也不是包名，也是路径名
- ×××××.SayHello() 这里使用的才是包名！
- 指定×××路径名就代表了此目录下唯一的包，编译器连接器默认就会去生成或者使用它，而不需要我们手动指明！
- 一个目录下就只能有一个包存在
- 对于调用有源码的第三方包，连接器在连接时，其实使用的并不是我们工作目录下的.a文件，而是以该最新源码编译出的临时文件夹中的.a文件
- 对于调用没有源码的第三方包，上面的临时编译不可能成功，那么临时目录下就不可能有.a文件，所以最后链接时就只能链接到工作目录下的.a文件
- 对于标准库，即便是修改了源代码，只要不重新编译Go源码，那么链接时使用的就还是已经编译好的*.a文件
- 包导入有三种模式：正常模式、别名模式、简便模式

### 3、包导入的语法

#### 正常模式导入

在写Go代码的时候经常用到import这个命令用来导入包文件，看到的方式参考如下：

```go
import (
    "fmt"
)
```

然后在代码里面可以通过如下的方式调用

```go
fmt.Println("hello world")
```

上面这个fmt是Go语言的标准库，其实是去GOROOT下去加载该模块。

```go
import (
    . "fmt"
)
```

这个点操作的含义就是这个包导入之后在你调用这个包的函数时，你可以省略前缀的包名，也就是前面你调用的`fmt.Println(“hello world”)` 可以省略的写成`Println(“hello world”)`。
***注意：该包内的函数不能与其重名。***

#### 别名操作

```go
import( 
    f “fmt” 
) 
```

别名操作顾名思义可以把包命名成另一个用起来容易记忆的名字，别名操作调用包函数时前缀变成了重命名的前缀，即`f.Println(“hello world”)`。

#### _操作

这个操作经常是让很多人费解的一个操作符，请看下面这个`import`

```go
import (
    _ "github.com/go-sql-driver/mysql"
) 
```

`_`操作其实只是引入该包。当导入一个包时，它所有的`init()`函数就会被执行，但有些时候并非真的需要使用这些包，仅仅是希望它的`init()`函数被执 行而已。这个时候就可以使用`_`操作引用该包了。即使用_操作引用包是无法通过包名来调用包中的导出函数，而是只是为了简单的调用其`init`函数()。

### 4、引用相关文档

- [golang 包原理](https://segmentfault.com/a/1190000012325912?utm_medium=referral&utm_source=tuicool)
- [Golang import 包问题相关详解](https://blog.csdn.net/cmbug/article/details/49339341)
- [理解Golang包导入](https://tonybai.com/2015/03/09/understanding-import-packages/)

