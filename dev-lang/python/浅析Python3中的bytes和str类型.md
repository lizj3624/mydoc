[toc]
### 浅析Python3中的bytes和str类型
`Python3`最重要的新特性之一是对字符串和二进制数据流做了明确的区分。文本总是`Unicode`，由`str`类型表示，二进制数据则由`bytes`类型表示。`Python3`不会以任意隐式的方式混用`str`和`bytes`，你不能拼接字符串和字节流，也无法在字节流里搜索字符串（反之亦然），也不能将字符串传入参数为字节流的函数（反之亦然）。

下面让我们深入分析一下二者的区别和联系。

#### 编码发展的历史   
在谈`bytes`和`str`之前，需要先说说关于编码是如何发展的。。   
在计算机历史的早期，美国为代表的英语系国家主导了整个计算机行业，26个英文字母组成了多样的英语单词、语句、文章。因此，最早的字符编码规范是`ASCII`码，一种`8`位即`1`个字节的编码规范，它可以涵盖整个英语系的编码需要。

**编码是什么？编码就是把一个字符用一个二进制来表示**。我们都知道，所有的东西，不管是英文、中文还是符号等等，最终存储在磁盘上都是`01010101`这类东西。在计算机内部，读取和存储数据归根结底，处理的都是`0`和`1`组成的比特流。问题来了，人类看不懂这些比特流，如何让这些`010101`对人类变得可读呢？于是出现了字符编码，它是个翻译机，在计算机内部某个地方，透明的帮我们将比特流翻译成人类可以直接理解的文字。对于一般用户，不需要知道这个过程是什么原理，是怎么执行的。但是对于程序员却是个必须搞清楚的问题。

以`ASCII`编码为例，它规定1个字节`8`个比特位代表1个字符的编码，也就是`00000000`这么宽，一个一个字节的解读。例如：`01000001`表示大写字母`A`，有时我们会“偷懒"的用`65`这个十进制来表示`A`在`ASCII`中的编码。8个比特位，可以没有重复的最多表示`2`的`8`次方(`255`)个字符。

后来，计算机得到普及，中文、日文、韩文等等国家的文字需要在计算机内表示，`ASCII`的`255`位远远不够，**于是标准组织制定出了叫做`UNICODE`的万国码，它规定任何一个字符（不管哪国的）至少以2个字节表示，可以更多**。其中，**英文字母就是用2个字节，而汉字是3个字**节。这个编码虽然很好，满足了所有人的要求，但是它不兼容`ASCII`，同时还占用较多的空间和内存。因为，在计算机世界更多的字符是英文字母，明明可以1个字节就能够表示，非要用2个。**于是`UTF-8`编码应运而生，它规定英文字母系列用1个字节表示，汉字用3个字节表示**等等。因此，它兼容`ASCII`，可以解码早期的文档。`UTF-8`很快就得到了广泛的应用。在编码的发展历程中，我国还创造了自己的编码方式，例如GBK，GB2312，BIG5。他们只局限于在国内使用，不被国外认可。在`GBK`编码中，中文汉字占2个字节。

#### bytes和str之间的异同
回到`bytes`和`str`的身上。`bytes`是一种比特流，它的存在形式是`01010001110`这种。我们无论是在写代码，还是阅读文章的过程中，肯定不会有人直接阅读这种比特流，它必须有一个编码方式，使得它变成有意义的比特流，而不是一堆晦涩难懂的01组合。因为编码方式的不同，对这个比特流的解读也会不同，对实际使用造成了很大的困扰。下面让我们看看`Python`是如何处理这一系列编码问题的：
```python
>>> s = "中文"
>>> s
'中文'
>>> type(s)
<class 'str'>
>>> b = bytes(s, encoding='utf-8')
>>> b
b'\xe4\xb8\xad\xe6\x96\x87'
>>> type(b)
<class 'bytes'>
```
从例子可以看出，`s`是个字符串类型。`Python`有个内置函数`bytes()`可以将字符串`str`类型转换成`bytes`类型，`b`实际上是一串`01`的组合，但为了在`ide`环境中让我们相对直观的观察，它被表现成了`b'\xe4\xb8\xad\xe6\x96\x87'`这种形式，开头的`b`表示这是一个`bytes`类型。`\xe4`是十六进制的表示方式，它占用1个字节的长度，因此`中文`被编码成`utf-8`后，我们可以数得出一共用了6个字节，每个汉字占用3个，这印证了上面的论述。在使用内置函数`bytes()`的时候，必须明确`encoding`的参数，不可省略。

我们都知道，字符串类`str`里有一个`encode()`方法，它是从字符串向比特流的编码过程。而`bytes`类型恰好有个`decode()`方法，它是从比特流向字符串解码的过程。除此之外，我们查看`Python`源码会发现bytes和str拥有几乎一模一样的方法列表，最大的区别就是`encode`和`decode`。

从实质上来说，字符串在磁盘上的保存形式也是01的组合，也需要编码解码。

如果，上面的阐述还不能让你搞清楚两者的区别，那么记住下面两几句话：

- 在将字符串存入磁盘和从磁盘读取字符串的过程中，Python自动地帮你完成了编码和解码的工作，你不需要关心它的过程。

- 使用bytes类型，实质上是告诉Python，不需要它帮你自动地完成编码和解码的工作，而是用户自己手动进行，并指定编码格式。

- Python已经严格区分了bytes和str两种数据类型，你不能在需要bytes类型参数的时候使用str参数，反之亦然。这点在读写磁盘文件时容易碰到。

#### bytes和str的互相转换
在bytes和str的互相转换过程中，实际就是编码解码的过程，必须显式地指定编码格式。
```python
>>> s = '中文'
>>> s
'中文'
>>> type(s)
<class 'str'>
>>> b = s.encode('utf-8')
>>> b
b'\xe4\xb8\xad\xe6\x96\x87'
>>> type(b)
<class 'bytes'>
>>> ss = b.decode('utf-8')
>>> ss
'中文'
>>> type(ss)
<class 'str'>
```

#### bytearray
`bytearray()` 方法返回一个新字节数组。这个数组里的元素是可变的，并且每个元素的值范围: `0 <= x < 256`。
```python
class bytearray([source[, encoding[, errors]]])
```
如果 source 为整数，则返回一个长度为 source 的初始化数组；

如果 source 为字符串，则按照指定的 encoding 将字符串转换为字节序列；

如果 source 为可迭代类型，则元素必须为[0 ,255] 中的整数；

如果 source 为与 buffer 接口一致的对象，则此对象也可以被用于初始化 bytearray。

```python
>>>bytearray()
bytearray(b'')
>>> bytearray([1,2,3])
bytearray(b'\x01\x02\x03')
>>> bytearray('test', 'utf-8')
bytearray(b'test')
>>>
```
#### 引用
- [浅析Python3中的bytes和str类型](http://chown-jane-y.coding.me/2017/03/02/%E6%B5%85%E6%9E%90Python3%E4%B8%AD%E7%9A%84bytes%E5%92%8Cstr%E7%B1%BB%E5%9E%8B/)
- [官方bytes文档](https://docs.python.org/zh-cn/3/library/stdtypes.html#binary-sequence-types-bytes-bytearray-memoryview)